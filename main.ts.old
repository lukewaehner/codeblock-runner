import {
	App,
	Modal,
	Notice,
	Plugin,
	PluginSettingTab,
	Setting,
} from "obsidian";
import { spawn } from "child_process";

interface CodeRunnerSettings {
	pythonCommand: string;
	executionTimeout: number;
}

const DEFAULT_SETTINGS: CodeRunnerSettings = {
	pythonCommand: "python3",
	executionTimeout: 30,
};

// Map language identifiers to execution commands
const LANGUAGE_COMMANDS: Record<
	string,
	(settings: CodeRunnerSettings) => string[]
> = {
	python: (settings) => [settings.pythonCommand, "-c"],
	py: (settings) => [settings.pythonCommand, "-c"],
};

// Plugin-specific code extractors
// These handle popular Obsidian plugins that modify code block rendering
interface CodeExtractor {
	name: string;
	pluginId?: string; // Optional: Obsidian plugin ID to check if enabled
	detect: (codeElement: Element) => boolean;
	extract: (codeElement: Element) => string;
}

// Registry of known plugin extractors
// These are only used if the corresponding plugin is detected/enabled
const PLUGIN_EXTRACTOR_REGISTRY: CodeExtractor[] = [
	// Code Styler plugin support
	{
		name: "code-styler",
		pluginId: "code-styler", // Official plugin ID
		detect: (el) => el.querySelector(".code-styler-line") !== null,
		extract: (el) => {
			const lines = el.querySelectorAll(".code-styler-line-text");
			if (lines.length > 0) {
				return Array.from(lines)
					.map((line) => line.textContent || "")
					.join("\n");
			}
			return "";
		},
	},
	// Add more plugin extractors here as needed
	// Example for future plugins:
	// {
	//   name: "another-code-plugin",
	//   pluginId: "another-code-plugin",
	//   detect: (el) => el.querySelector(".another-plugin-class") !== null,
	//   extract: (el) => { ... }
	// }
];

function getActiveExtractors(app: App): CodeExtractor[] {
	const activeExtractors: CodeExtractor[] = [];

	for (const extractor of PLUGIN_EXTRACTOR_REGISTRY) {
		// If pluginId is specified, check if plugin is enabled
		if (extractor.pluginId) {
			// @ts-ignore - accessing internal API
			const isEnabled = app.plugins?.enabledPlugins?.has(
				extractor.pluginId
			);
			if (isEnabled) {
				console.log(
					`[CodeRunner] Plugin detected: ${extractor.name} (${extractor.pluginId})`
				);
				activeExtractors.push(extractor);
			}
		} else {
			// No pluginId means always try this extractor
			activeExtractors.push(extractor);
		}
	}

	return activeExtractors;
}

function extractCodeFromElement(codeElement: Element, app: App): string {
	console.log("[CodeRunner] Attempting to extract code...");

	// Get extractors for currently enabled plugins
	const activeExtractors = getActiveExtractors(app);
	console.log(
		`[CodeRunner] ${activeExtractors.length} plugin extractor(s) active`
	);

	// Try plugin-specific extractors first
	for (const extractor of activeExtractors) {
		if (extractor.detect(codeElement)) {
			console.log(
				`[CodeRunner] Detected ${extractor.name} plugin format`
			);
			const extracted = extractor.extract(codeElement);
			if (extracted) {
				console.log(
					`[CodeRunner] Successfully extracted using ${extractor.name} extractor`
				);
				return extracted;
			}
		}
	}

	console.log(
		"[CodeRunner] No plugin format detected, using standard extraction"
	);

	// Fallback: standard extraction with line number stripping
	let codeText = codeElement.textContent ?? "";

	// If line numbers are present (format: "  1|code" or "  1 code")
	// Remove them from each line
	const lines = codeText.split("\n");
	const hasLineNumbers =
		lines.length > 1 &&
		lines.every((line) => line.match(/^\s*\d+[|\s]/) || line.trim() === "");

	if (hasLineNumbers) {
		console.log("[CodeRunner] Detected inline line numbers, stripping...");
		codeText = lines
			.map((line) => line.replace(/^\s*\d+[|\s]/, ""))
			.join("\n");
	}

	return codeText;
}

interface ExecutionResult {
	stdout: string;
	stderr: string;
	exitCode: number | null;
	executionTime: number;
	timedOut: boolean;
}

async function executeCode(
	code: string,
	language: string,
	settings: CodeRunnerSettings
): Promise<ExecutionResult> {
	const startTime = Date.now();

	return new Promise((resolve) => {
		const commandBuilder = LANGUAGE_COMMANDS[language.toLowerCase()];

		if (!commandBuilder) {
			resolve({
				stdout: "",
				stderr: `Unsupported language: ${language}\nCurrently supported: Python`,
				exitCode: 1,
				executionTime: 0,
				timedOut: false,
			});
			return;
		}

		const [command, ...baseArgs] = commandBuilder(settings);
		const args = [...baseArgs, code];

		let stdout = "";
		let stderr = "";
		let timedOut = false;

		const process = spawn(command, args);

		// Set up timeout
		const timeout = setTimeout(() => {
			timedOut = true;
			process.kill();
		}, settings.executionTimeout * 1000);

		process.stdout.on("data", (data) => {
			stdout += data.toString();
		});

		process.stderr.on("data", (data) => {
			stderr += data.toString();
		});

		process.on("error", (error) => {
			clearTimeout(timeout);
			resolve({
				stdout,
				stderr: `Failed to execute: ${error.message}\n\nMake sure ${command} is installed and in your PATH.`,
				exitCode: 1,
				executionTime: Date.now() - startTime,
				timedOut: false,
			});
		});

		process.on("close", (exitCode) => {
			clearTimeout(timeout);
			const executionTime = Date.now() - startTime;

			resolve({
				stdout,
				stderr: timedOut
					? `Execution timed out after ${settings.executionTimeout}s`
					: stderr,
				exitCode,
				executionTime,
				timedOut,
			});
		});
	});
}

class OutputModal extends Modal {
	result: ExecutionResult;
	language: string;

	constructor(app: App, result: ExecutionResult, language: string) {
		super(app);
		this.result = result;
		this.language = language;
	}

	onOpen() {
		const { contentEl } = this;
		contentEl.empty();
		contentEl.addClass("codeblock-runner-output");

		// Title
		contentEl.createEl("h2", { text: `Output (${this.language})` });

		// Create output container
		const outputContainer = contentEl.createDiv({
			cls: "output-container",
		});

		// Stdout
		if (this.result.stdout) {
			const stdoutSection = outputContainer.createDiv({
				cls: "output-section",
			});
			stdoutSection.createEl("h3", { text: "Output" });
			const stdoutPre = stdoutSection.createEl("pre");
			stdoutPre.createEl("code", { text: this.result.stdout });
		}

		// Stderr
		if (this.result.stderr) {
			const stderrSection = outputContainer.createDiv({
				cls: "output-section output-error",
			});
			stderrSection.createEl("h3", {
				text: this.result.timedOut ? "Timeout" : "Error",
			});
			const stderrPre = stderrSection.createEl("pre");
			stderrPre.createEl("code", { text: this.result.stderr });
		}

		// Execution info
		const infoSection = outputContainer.createDiv({ cls: "output-info" });

		if (this.result.exitCode !== null && this.result.exitCode !== 0) {
			infoSection.createEl("div", {
				text: `Exit code: ${this.result.exitCode}`,
				cls: "exit-code-error",
			});
		}

		infoSection.createEl("div", {
			text: `Executed in ${(this.result.executionTime / 1000).toFixed(
				2
			)}s`,
		});

		// Close button
		const buttonContainer = contentEl.createDiv({
			cls: "button-container",
		});
		const closeButton = buttonContainer.createEl("button", {
			text: "Close",
		});
		closeButton.addEventListener("click", () => this.close());
	}

	onClose() {
		const { contentEl } = this;
		contentEl.empty();
	}
}

export default class CodeBlockRunner extends Plugin {
	settings: CodeRunnerSettings;

	async onload() {
		await this.loadSettings();

		// Register settings tab
		this.addSettingTab(new CodeBlockRunnerSettingTab(this.app, this));

		this.registerMarkdownPostProcessor((el) => {
			el.querySelectorAll("pre > code").forEach((code) => {
				const pre = code.parentElement as HTMLElement;
				if (pre.dataset.codeRunner === "1") return;
				pre.dataset.codeRunner = "1";

				pre.style.position = pre.style.position || "relative";
				pre.style.overflow = "visible";

				const btn = document.createElement("button");
				btn.textContent = "Run Code";
				btn.className = "mod-cta";
				Object.assign(btn.style, {
					position: "absolute",
					bottom: "5px",
					right: "5px",
					fontSize: "12px",
					zIndex: "10",
					pointerEvents: "auto",
				});

				this.registerDomEvent(btn, "click", async (e) => {
					e.preventDefault();
					e.stopPropagation();

					console.log("[CodeRunner] === Extraction Debug ===");
					console.log(
						"[CodeRunner] Code element HTML:",
						code.innerHTML?.substring(0, 500)
					);

					// Use the plugin-aware extraction system
					const codeText = extractCodeFromElement(code, this.app);

					console.log(
						"[CodeRunner] Final codeText length:",
						codeText.length
					);
					console.log(
						"[CodeRunner] Final codeText (first 200 chars):",
						codeText.substring(0, 200)
					);
					console.log("[CodeRunner] === End Debug ===");

					// Extract language from class
					const lang =
						code.className
							.match(/language-([\w+-]+)/i)?.[1]
							?.toLowerCase() ?? "txt";

					// Check if language is supported
					if (!LANGUAGE_COMMANDS[lang]) {
						new Notice(`Language "${lang}" is not supported yet`);
						return;
					}

					// Show executing notice
					const notice = new Notice(`Executing ${lang} code...`, 0);

					try {
						const result = await executeCode(
							codeText,
							lang,
							this.settings
						);

						notice.hide();

						// Show output modal
						new OutputModal(this.app, result, lang).open();

						// Show success/failure notice
						if (result.exitCode === 0 && !result.timedOut) {
							new Notice(`Code executed successfully`);
						} else if (result.timedOut) {
							new Notice(`Execution timed out`, 5000);
						} else {
							new Notice(
								`Execution failed (exit code: ${result.exitCode})`,
								5000
							);
						}
					} catch (err) {
						notice.hide();
						console.error("Code execution error:", err);
						new Notice(`Failed to execute code: ${err.message}`);
					}
				});

				pre.appendChild(btn);
			});
		});
	}

	onunload() {}

	async loadSettings() {
		this.settings = Object.assign(
			{},
			DEFAULT_SETTINGS,
			await this.loadData()
		);
	}

	async saveSettings() {
		await this.saveData(this.settings);
	}
}

class CodeBlockRunnerSettingTab extends PluginSettingTab {
	plugin: CodeBlockRunner;

	constructor(app: App, plugin: CodeBlockRunner) {
		super(app, plugin);
		this.plugin = plugin;
	}

	display(): void {
		const { containerEl } = this;

		containerEl.empty();

		containerEl.createEl("h2", { text: "Codeblock Runner Settings" });

		// Python command setting
		new Setting(containerEl)
			.setName("Python command")
			.setDesc(
				"The command to use for executing Python code (e.g., python3, python, or full path)"
			)
			.addText((text) =>
				text
					.setPlaceholder("python3")
					.setValue(this.plugin.settings.pythonCommand)
					.onChange(async (value) => {
						this.plugin.settings.pythonCommand = value || "python3";
						await this.plugin.saveSettings();
					})
			);

		// Execution timeout setting
		new Setting(containerEl)
			.setName("Execution timeout")
			.setDesc(
				"Maximum time (in seconds) a code block can run before being terminated"
			)
			.addText((text) =>
				text
					.setPlaceholder("30")
					.setValue(String(this.plugin.settings.executionTimeout))
					.onChange(async (value) => {
						const timeout = parseInt(value);
						if (!isNaN(timeout) && timeout > 0) {
							this.plugin.settings.executionTimeout = timeout;
							await this.plugin.saveSettings();
						}
					})
			);

		// Info section
		containerEl.createEl("h3", { text: "Supported Languages" });
		const langList = containerEl.createEl("ul");
		langList.createEl("li", { text: "Python (python, py)" });

		containerEl.createEl("p", {
			text: "More languages coming soon: C, C++, Rust",
			cls: "setting-item-description",
		});
	}
}
